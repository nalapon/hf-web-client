// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.5.1 with parameter "target=ts,keep_empty_files=true"
// @generated from file peer/proposal_response.proto (package protos, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { SignaturePolicyEnvelope } from "../common/policies_pb";
import { file_common_policies } from "../common/policies_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file peer/proposal_response.proto.
 */
export const file_peer_proposal_response: GenFile = /*@__PURE__*/
  fileDesc("ChxwZWVyL3Byb3Bvc2FsX3Jlc3BvbnNlLnByb3RvEgZwcm90b3Mi3gEKEFByb3Bvc2FsUmVzcG9uc2USDwoHdmVyc2lvbhgBIAEoBRItCgl0aW1lc3RhbXAYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiIKCHJlc3BvbnNlGAQgASgLMhAucHJvdG9zLlJlc3BvbnNlEg8KB3BheWxvYWQYBSABKAwSKAoLZW5kb3JzZW1lbnQYBiABKAsyEy5wcm90b3MuRW5kb3JzZW1lbnQSKwoIaW50ZXJlc3QYByABKAsyGS5wcm90b3MuQ2hhaW5jb2RlSW50ZXJlc3QiPAoIUmVzcG9uc2USDgoGc3RhdHVzGAEgASgFEg8KB21lc3NhZ2UYAiABKAkSDwoHcGF5bG9hZBgDIAEoDCJDChdQcm9wb3NhbFJlc3BvbnNlUGF5bG9hZBIVCg1wcm9wb3NhbF9oYXNoGAEgASgMEhEKCWV4dGVuc2lvbhgCIAEoDCIyCgtFbmRvcnNlbWVudBIQCghlbmRvcnNlchgBIAEoDBIRCglzaWduYXR1cmUYAiABKAwiPgoRQ2hhaW5jb2RlSW50ZXJlc3QSKQoKY2hhaW5jb2RlcxgBIAMoCzIVLnByb3Rvcy5DaGFpbmNvZGVDYWxsIsYBCg1DaGFpbmNvZGVDYWxsEgwKBG5hbWUYASABKAkSGAoQY29sbGVjdGlvbl9uYW1lcxgCIAMoCRIYChBub19wcml2YXRlX3JlYWRzGAMgASgIEhgKEG5vX3B1YmxpY193cml0ZXMYBCABKAgSNQoMa2V5X3BvbGljaWVzGAUgAygLMh8uY29tbW9uLlNpZ25hdHVyZVBvbGljeUVudmVsb3BlEiIKGmRpc3JlZ2FyZF9uYW1lc3BhY2VfcG9saWN5GAYgASgIQmsKIm9yZy5oeXBlcmxlZGdlci5mYWJyaWMucHJvdG9zLnBlZXJCF1Byb3Bvc2FsUmVzcG9uc2VQYWNrYWdlWixnaXRodWIuY29tL2h5cGVybGVkZ2VyL2ZhYnJpYy1wcm90b3MtZ28vcGVlcmIGcHJvdG8z", [file_google_protobuf_timestamp, file_common_policies]);

/**
 * A ProposalResponse is returned from an endorser to the proposal submitter.
 * The idea is that this message contains the endorser's response to the
 * request of a client to perform an action over a chaincode (or more
 * generically on the ledger); the response might be success/error (conveyed in
 * the Response field) together with a description of the action and a
 * signature over it by that endorser.  If a sufficient number of distinct
 * endorsers agree on the same action and produce signature to that effect, a
 * transaction can be generated and sent for ordering.
 *
 * @generated from message protos.ProposalResponse
 */
export type ProposalResponse = Message<"protos.ProposalResponse"> & {
  /**
   * Version indicates message protocol version
   *
   * @generated from field: int32 version = 1;
   */
  version: number;

  /**
   * Timestamp is the time that the message
   * was created as  defined by the sender
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * A response message indicating whether the
   * endorsement of the action was successful
   *
   * @generated from field: protos.Response response = 4;
   */
  response?: Response;

  /**
   * The payload of response. It is the bytes of ProposalResponsePayload
   *
   * @generated from field: bytes payload = 5;
   */
  payload: Uint8Array;

  /**
   * The endorsement of the proposal, basically
   * the endorser's signature over the payload
   *
   * @generated from field: protos.Endorsement endorsement = 6;
   */
  endorsement?: Endorsement;

  /**
   * The chaincode interest derived from simulating the proposal.
   *
   * @generated from field: protos.ChaincodeInterest interest = 7;
   */
  interest?: ChaincodeInterest;
};

/**
 * Describes the message protos.ProposalResponse.
 * Use `create(ProposalResponseSchema)` to create a new message.
 */
export const ProposalResponseSchema: GenMessage<ProposalResponse> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 0);

/**
 * A response with a representation similar to an HTTP response that can
 * be used within another message.
 *
 * @generated from message protos.Response
 */
export type Response = Message<"protos.Response"> & {
  /**
   * A status code that should follow the HTTP status codes.
   *
   * @generated from field: int32 status = 1;
   */
  status: number;

  /**
   * A message associated with the response code.
   *
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * A payload that can be used to include metadata with this response.
   *
   * @generated from field: bytes payload = 3;
   */
  payload: Uint8Array;
};

/**
 * Describes the message protos.Response.
 * Use `create(ResponseSchema)` to create a new message.
 */
export const ResponseSchema: GenMessage<Response> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 1);

/**
 * ProposalResponsePayload is the payload of a proposal response.  This message
 * is the "bridge" between the client's request and the endorser's action in
 * response to that request. Concretely, for chaincodes, it contains a hashed
 * representation of the proposal (proposalHash) and a representation of the
 * chaincode state changes and events inside the extension field.
 *
 * @generated from message protos.ProposalResponsePayload
 */
export type ProposalResponsePayload = Message<"protos.ProposalResponsePayload"> & {
  /**
   * Hash of the proposal that triggered this response. The hash is used to
   * link a response with its proposal, both for bookeeping purposes on an
   * asynchronous system and for security reasons (accountability,
   * non-repudiation). The hash usually covers the entire Proposal message
   * (byte-by-byte).
   *
   * @generated from field: bytes proposal_hash = 1;
   */
  proposalHash: Uint8Array;

  /**
   * Extension should be unmarshaled to a type-specific message. The type of
   * the extension in any proposal response depends on the type of the proposal
   * that the client selected when the proposal was initially sent out.  In
   * particular, this information is stored in the type field of a Header.  For
   * chaincode, it's a ChaincodeAction message
   *
   * @generated from field: bytes extension = 2;
   */
  extension: Uint8Array;
};

/**
 * Describes the message protos.ProposalResponsePayload.
 * Use `create(ProposalResponsePayloadSchema)` to create a new message.
 */
export const ProposalResponsePayloadSchema: GenMessage<ProposalResponsePayload> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 2);

/**
 * An endorsement is a signature of an endorser over a proposal response.  By
 * producing an endorsement message, an endorser implicitly "approves" that
 * proposal response and the actions contained therein. When enough
 * endorsements have been collected, a transaction can be generated out of a
 * set of proposal responses.  Note that this message only contains an identity
 * and a signature but no signed payload. This is intentional because
 * endorsements are supposed to be collected in a transaction, and they are all
 * expected to endorse a single proposal response/action (many endorsements
 * over a single proposal response)
 *
 * @generated from message protos.Endorsement
 */
export type Endorsement = Message<"protos.Endorsement"> & {
  /**
   * Identity of the endorser (e.g. its certificate)
   *
   * @generated from field: bytes endorser = 1;
   */
  endorser: Uint8Array;

  /**
   * Signature of the payload included in ProposalResponse concatenated with
   * the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message protos.Endorsement.
 * Use `create(EndorsementSchema)` to create a new message.
 */
export const EndorsementSchema: GenMessage<Endorsement> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 3);

/**
 * ChaincodeInterest defines an interest about an endorsement
 * for a specific single chaincode invocation.
 * Multiple chaincodes indicate chaincode to chaincode invocations.
 *
 * @generated from message protos.ChaincodeInterest
 */
export type ChaincodeInterest = Message<"protos.ChaincodeInterest"> & {
  /**
   * @generated from field: repeated protos.ChaincodeCall chaincodes = 1;
   */
  chaincodes: ChaincodeCall[];
};

/**
 * Describes the message protos.ChaincodeInterest.
 * Use `create(ChaincodeInterestSchema)` to create a new message.
 */
export const ChaincodeInterestSchema: GenMessage<ChaincodeInterest> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 4);

/**
 * ChaincodeCall defines a call to a chaincode.
 * It may have collections that are related to the chaincode
 *
 * @generated from message protos.ChaincodeCall
 */
export type ChaincodeCall = Message<"protos.ChaincodeCall"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated string collection_names = 2;
   */
  collectionNames: string[];

  /**
   * Indicates we do not need to read from private data
   *
   * @generated from field: bool no_private_reads = 3;
   */
  noPrivateReads: boolean;

  /**
   * Indicates we do not need to write to the chaincode namespace
   *
   * @generated from field: bool no_public_writes = 4;
   */
  noPublicWrites: boolean;

  /**
   * The set of signature policies associated with states in the write-set
   * that have state-based endorsement policies.
   *
   * @generated from field: repeated common.SignaturePolicyEnvelope key_policies = 5;
   */
  keyPolicies: SignaturePolicyEnvelope[];

  /**
   * Indicates we wish to ignore the namespace endorsement policy
   *
   * @generated from field: bool disregard_namespace_policy = 6;
   */
  disregardNamespacePolicy: boolean;
};

/**
 * Describes the message protos.ChaincodeCall.
 * Use `create(ChaincodeCallSchema)` to create a new message.
 */
export const ChaincodeCallSchema: GenMessage<ChaincodeCall> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 5);

