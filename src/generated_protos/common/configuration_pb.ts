// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.5.1 with parameter "target=ts,keep_empty_files=true"
// @generated from file common/configuration.proto (package common, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file common/configuration.proto.
 */
export const file_common_configuration: GenFile = /*@__PURE__*/
  fileDesc("Chpjb21tb24vY29uZmlndXJhdGlvbi5wcm90bxIGY29tbW9uIiAKEEhhc2hpbmdBbGdvcml0aG0SDAoEbmFtZRgBIAEoCSIqChlCbG9ja0RhdGFIYXNoaW5nU3RydWN0dXJlEg0KBXdpZHRoGAEgASgNIiUKEE9yZGVyZXJBZGRyZXNzZXMSEQoJYWRkcmVzc2VzGAEgAygJIocBCglDb25zZW50ZXISCgoCaWQYASABKA0SDAoEaG9zdBgCIAEoCRIMCgRwb3J0GAMgASgNEg4KBm1zcF9pZBgEIAEoCRIQCghpZGVudGl0eRgFIAEoDBIXCg9jbGllbnRfdGxzX2NlcnQYBiABKAwSFwoPc2VydmVyX3Rsc19jZXJ0GAcgASgMIjgKCE9yZGVyZXJzEiwKEWNvbnNlbnRlcl9tYXBwaW5nGAEgAygLMhEuY29tbW9uLkNvbnNlbnRlciIaCgpDb25zb3J0aXVtEgwKBG5hbWUYASABKAkilQEKDENhcGFiaWxpdGllcxI8CgxjYXBhYmlsaXRpZXMYASADKAsyJi5jb21tb24uQ2FwYWJpbGl0aWVzLkNhcGFiaWxpdGllc0VudHJ5GkcKEUNhcGFiaWxpdGllc0VudHJ5EgsKA2tleRgBIAEoCRIhCgV2YWx1ZRgCIAEoCzISLmNvbW1vbi5DYXBhYmlsaXR5OgI4ASIMCgpDYXBhYmlsaXR5QlYKJG9yZy5oeXBlcmxlZGdlci5mYWJyaWMucHJvdG9zLmNvbW1vblouZ2l0aHViLmNvbS9oeXBlcmxlZGdlci9mYWJyaWMtcHJvdG9zLWdvL2NvbW1vbmIGcHJvdG8z");

/**
 * HashingAlgorithm is encoded into the configuration transaction as a
 * configuration item of type Chain with a Key of "HashingAlgorithm" and a
 * Value of HashingAlgorithm as marshaled protobuf bytes
 *
 * @generated from message common.HashingAlgorithm
 */
export type HashingAlgorithm = Message<"common.HashingAlgorithm"> & {
  /**
   * SHA256 is currently the only supported and tested algorithm.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message common.HashingAlgorithm.
 * Use `create(HashingAlgorithmSchema)` to create a new message.
 */
export const HashingAlgorithmSchema: GenMessage<HashingAlgorithm> = /*@__PURE__*/
  messageDesc(file_common_configuration, 0);

/**
 * BlockDataHashingStructure is encoded into the configuration transaction as a configuration item of
 * type Chain with a Key of "BlockDataHashingStructure" and a Value of HashingAlgorithm as marshaled protobuf bytes
 *
 * @generated from message common.BlockDataHashingStructure
 */
export type BlockDataHashingStructure = Message<"common.BlockDataHashingStructure"> & {
  /**
   * width specifies the width of the Merkle tree to use when computing the BlockDataHash
   * in order to replicate flat hashing, set this width to MAX_UINT32
   *
   * @generated from field: uint32 width = 1;
   */
  width: number;
};

/**
 * Describes the message common.BlockDataHashingStructure.
 * Use `create(BlockDataHashingStructureSchema)` to create a new message.
 */
export const BlockDataHashingStructureSchema: GenMessage<BlockDataHashingStructure> = /*@__PURE__*/
  messageDesc(file_common_configuration, 1);

/**
 * OrdererAddresses is encoded into the configuration transaction as a configuration item of type Chain
 * with a Key of "OrdererAddresses" and a Value of OrdererAddresses as marshaled protobuf bytes
 *
 * @generated from message common.OrdererAddresses
 */
export type OrdererAddresses = Message<"common.OrdererAddresses"> & {
  /**
   * @generated from field: repeated string addresses = 1;
   */
  addresses: string[];
};

/**
 * Describes the message common.OrdererAddresses.
 * Use `create(OrdererAddressesSchema)` to create a new message.
 */
export const OrdererAddressesSchema: GenMessage<OrdererAddresses> = /*@__PURE__*/
  messageDesc(file_common_configuration, 2);

/**
 * Consenter represents a consenting node (i.e. replica).
 *
 * @generated from message common.Consenter
 */
export type Consenter = Message<"common.Consenter"> & {
  /**
   * @generated from field: uint32 id = 1;
   */
  id: number;

  /**
   * @generated from field: string host = 2;
   */
  host: string;

  /**
   * @generated from field: uint32 port = 3;
   */
  port: number;

  /**
   * @generated from field: string msp_id = 4;
   */
  mspId: string;

  /**
   * @generated from field: bytes identity = 5;
   */
  identity: Uint8Array;

  /**
   * @generated from field: bytes client_tls_cert = 6;
   */
  clientTlsCert: Uint8Array;

  /**
   * @generated from field: bytes server_tls_cert = 7;
   */
  serverTlsCert: Uint8Array;
};

/**
 * Describes the message common.Consenter.
 * Use `create(ConsenterSchema)` to create a new message.
 */
export const ConsenterSchema: GenMessage<Consenter> = /*@__PURE__*/
  messageDesc(file_common_configuration, 3);

/**
 * Orderers is encoded into the configuration transaction as a configuration item of type Chain
 * with a Key of "Orderers" and a Value of Orderers as marshaled protobuf bytes
 *
 * @generated from message common.Orderers
 */
export type Orderers = Message<"common.Orderers"> & {
  /**
   * @generated from field: repeated common.Consenter consenter_mapping = 1;
   */
  consenterMapping: Consenter[];
};

/**
 * Describes the message common.Orderers.
 * Use `create(OrderersSchema)` to create a new message.
 */
export const OrderersSchema: GenMessage<Orderers> = /*@__PURE__*/
  messageDesc(file_common_configuration, 4);

/**
 * Consortium represents the consortium context in which the channel was created
 *
 * @generated from message common.Consortium
 */
export type Consortium = Message<"common.Consortium"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message common.Consortium.
 * Use `create(ConsortiumSchema)` to create a new message.
 */
export const ConsortiumSchema: GenMessage<Consortium> = /*@__PURE__*/
  messageDesc(file_common_configuration, 5);

/**
 * Capabilities message defines the capabilities a particular binary must implement
 * for that binary to be able to safely participate in the channel.  The capabilities
 * message is defined at the /Channel level, the /Channel/Application level, and the
 * /Channel/Orderer level.
 *
 * The /Channel level capabilties define capabilities which both the orderer and peer
 * binaries must satisfy.  These capabilties might be things like a new MSP type,
 * or a new policy type.
 *
 * The /Channel/Orderer level capabilties define capabilities which must be supported
 * by the orderer, but which have no bearing on the behavior of the peer.  For instance
 * if the orderer changes the logic for how it constructs new channels, only all orderers
 * must agree on the new logic.  The peers do not need to be aware of this change as
 * they only interact with the channel after it has been constructed.
 *
 * Finally, the /Channel/Application level capabilities define capabilities which the peer
 * binary must satisfy, but which have no bearing on the orderer.  For instance, if the
 * peer adds a new UTXO transaction type, or changes the chaincode lifecycle requirements,
 * all peers must agree on the new logic.  However, orderers never inspect transactions
 * this deeply, and therefore have no need to be aware of the change.
 *
 * The capabilities strings defined in these messages typically correspond to release
 * binary versions (e.g. "V1.1"), and are used primarilly as a mechanism for a fully
 * upgraded network to switch from one set of logic to a new one.
 *
 * Although for V1.1, the orderers must be upgraded to V1.1 prior to the rest of the
 * network, going forward, because of the split between the /Channel, /Channel/Orderer
 * and /Channel/Application capabilities.  It should be possible for the orderer and
 * application networks to upgrade themselves independently (with the exception of any
 * new capabilities defined at the /Channel level).
 *
 * @generated from message common.Capabilities
 */
export type Capabilities = Message<"common.Capabilities"> & {
  /**
   * @generated from field: map<string, common.Capability> capabilities = 1;
   */
  capabilities: { [key: string]: Capability };
};

/**
 * Describes the message common.Capabilities.
 * Use `create(CapabilitiesSchema)` to create a new message.
 */
export const CapabilitiesSchema: GenMessage<Capabilities> = /*@__PURE__*/
  messageDesc(file_common_configuration, 6);

/**
 * Capability is an empty message for the time being.  It is defined as a protobuf
 * message rather than a constant, so that we may extend capabilities with other fields
 * if the need arises in the future.  For the time being, a capability being in the
 * capabilities map requires that that capability be supported.
 *
 * @generated from message common.Capability
 */
export type Capability = Message<"common.Capability"> & {
};

/**
 * Describes the message common.Capability.
 * Use `create(CapabilitySchema)` to create a new message.
 */
export const CapabilitySchema: GenMessage<Capability> = /*@__PURE__*/
  messageDesc(file_common_configuration, 7);

