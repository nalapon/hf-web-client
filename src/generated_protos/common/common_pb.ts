// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.5.1 with parameter "target=ts,keep_empty_files=true"
// @generated from file common/common.proto (package common, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file common/common.proto.
 */
export const file_common_common: GenFile = /*@__PURE__*/
  fileDesc("ChNjb21tb24vY29tbW9uLnByb3RvEgZjb21tb24iGwoKTGFzdENvbmZpZxINCgVpbmRleBgBIAEoBCJICghNZXRhZGF0YRINCgV2YWx1ZRgBIAEoDBItCgpzaWduYXR1cmVzGAIgAygLMhkuY29tbW9uLk1ldGFkYXRhU2lnbmF0dXJlIlsKEU1ldGFkYXRhU2lnbmF0dXJlEhgKEHNpZ25hdHVyZV9oZWFkZXIYASABKAwSEQoJc2lnbmF0dXJlGAIgASgMEhkKEWlkZW50aWZpZXJfaGVhZGVyGAMgASgMIjUKEElkZW50aWZpZXJIZWFkZXISEgoKaWRlbnRpZmllchgBIAEoDRINCgVub25jZRgCIAEoDCI6CgZIZWFkZXISFgoOY2hhbm5lbF9oZWFkZXIYASABKAwSGAoQc2lnbmF0dXJlX2hlYWRlchgCIAEoDCK5AQoNQ2hhbm5lbEhlYWRlchIMCgR0eXBlGAEgASgFEg8KB3ZlcnNpb24YAiABKAUSLQoJdGltZXN0YW1wGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBISCgpjaGFubmVsX2lkGAQgASgJEg0KBXR4X2lkGAUgASgJEg0KBWVwb2NoGAYgASgEEhEKCWV4dGVuc2lvbhgHIAEoDBIVCg10bHNfY2VydF9oYXNoGAggASgMIjEKD1NpZ25hdHVyZUhlYWRlchIPCgdjcmVhdG9yGAEgASgMEg0KBW5vbmNlGAIgASgMIjcKB1BheWxvYWQSHgoGaGVhZGVyGAEgASgLMg4uY29tbW9uLkhlYWRlchIMCgRkYXRhGAIgASgMIi4KCEVudmVsb3BlEg8KB3BheWxvYWQYASABKAwSEQoJc2lnbmF0dXJlGAIgASgMInYKBUJsb2NrEiMKBmhlYWRlchgBIAEoCzITLmNvbW1vbi5CbG9ja0hlYWRlchIfCgRkYXRhGAIgASgLMhEuY29tbW9uLkJsb2NrRGF0YRInCghtZXRhZGF0YRgDIAEoCzIVLmNvbW1vbi5CbG9ja01ldGFkYXRhIkcKC0Jsb2NrSGVhZGVyEg4KBm51bWJlchgBIAEoBBIVCg1wcmV2aW91c19oYXNoGAIgASgMEhEKCWRhdGFfaGFzaBgDIAEoDCIZCglCbG9ja0RhdGESDAoEZGF0YRgBIAMoDCIhCg1CbG9ja01ldGFkYXRhEhAKCG1ldGFkYXRhGAEgAygMIlsKFE9yZGVyZXJCbG9ja01ldGFkYXRhEicKC2xhc3RfY29uZmlnGAEgASgLMhIuY29tbW9uLkxhc3RDb25maWcSGgoSY29uc2VudGVyX21ldGFkYXRhGAIgASgMKsABCgZTdGF0dXMSCwoHVU5LTk9XThAAEgwKB1NVQ0NFU1MQyAESEAoLQkFEX1JFUVVFU1QQkAMSDgoJRk9SQklEREVOEJMDEg4KCU5PVF9GT1VORBCUAxIdChhSRVFVRVNUX0VOVElUWV9UT09fTEFSR0UQnQMSGgoVSU5URVJOQUxfU0VSVkVSX0VSUk9SEPQDEhQKD05PVF9JTVBMRU1FTlRFRBD1AxIYChNTRVJWSUNFX1VOQVZBSUxBQkxFEPcDKu4BCgpIZWFkZXJUeXBlEgsKB01FU1NBR0UQABIKCgZDT05GSUcQARIRCg1DT05GSUdfVVBEQVRFEAISGAoURU5ET1JTRVJfVFJBTlNBQ1RJT04QAxIbChNPUkRFUkVSX1RSQU5TQUNUSU9OEAQaAggBEhUKEURFTElWRVJfU0VFS19JTkZPEAUSFQoRQ0hBSU5DT0RFX1BBQ0tBR0UQBiIECAcQByIECAgQCCIECAkQCSoUUEVFUl9SRVNPVVJDRV9VUERBVEUqFFBFRVJfQURNSU5fT1BFUkFUSU9OKhFUT0tFTl9UUkFOU0FDVElPTip0ChJCbG9ja01ldGFkYXRhSW5kZXgSDgoKU0lHTkFUVVJFUxAAEhMKC0xBU1RfQ09ORklHEAEaAggBEhcKE1RSQU5TQUNUSU9OU19GSUxURVIQAhIPCgdPUkRFUkVSEAMaAggBEg8KC0NPTU1JVF9IQVNIEARCVgokb3JnLmh5cGVybGVkZ2VyLmZhYnJpYy5wcm90b3MuY29tbW9uWi5naXRodWIuY29tL2h5cGVybGVkZ2VyL2ZhYnJpYy1wcm90b3MtZ28vY29tbW9uYgZwcm90bzM", [file_google_protobuf_timestamp]);

/**
 * LastConfig is the encoded value for the Metadata message which is encoded in the LAST_CONFIGURATION block metadata index
 *
 * @generated from message common.LastConfig
 */
export type LastConfig = Message<"common.LastConfig"> & {
  /**
   * @generated from field: uint64 index = 1;
   */
  index: bigint;
};

/**
 * Describes the message common.LastConfig.
 * Use `create(LastConfigSchema)` to create a new message.
 */
export const LastConfigSchema: GenMessage<LastConfig> = /*@__PURE__*/
  messageDesc(file_common_common, 0);

/**
 * Metadata is a common structure to be used to encode block metadata
 *
 * @generated from message common.Metadata
 */
export type Metadata = Message<"common.Metadata"> & {
  /**
   * @generated from field: bytes value = 1;
   */
  value: Uint8Array;

  /**
   * @generated from field: repeated common.MetadataSignature signatures = 2;
   */
  signatures: MetadataSignature[];
};

/**
 * Describes the message common.Metadata.
 * Use `create(MetadataSchema)` to create a new message.
 */
export const MetadataSchema: GenMessage<Metadata> = /*@__PURE__*/
  messageDesc(file_common_common, 1);

/**
 * @generated from message common.MetadataSignature
 */
export type MetadataSignature = Message<"common.MetadataSignature"> & {
  /**
   * An encoded SignatureHeader
   *
   * @generated from field: bytes signature_header = 1;
   */
  signatureHeader: Uint8Array;

  /**
   * The signature over the concatenation of the Metadata value bytes, signatureHeader, and block header
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;

  /**
   * An encoded IdentifierHeader. If the signature header is empty, this is used to identify the creator by id
   *
   * @generated from field: bytes identifier_header = 3;
   */
  identifierHeader: Uint8Array;
};

/**
 * Describes the message common.MetadataSignature.
 * Use `create(MetadataSignatureSchema)` to create a new message.
 */
export const MetadataSignatureSchema: GenMessage<MetadataSignature> = /*@__PURE__*/
  messageDesc(file_common_common, 2);

/**
 * IdentifierHeader is used as an alternative to a SignatureHeader when the creator can be referenced by id
 *
 * @generated from message common.IdentifierHeader
 */
export type IdentifierHeader = Message<"common.IdentifierHeader"> & {
  /**
   * A unique identifier that represents the creator of the message
   *
   * @generated from field: uint32 identifier = 1;
   */
  identifier: number;

  /**
   * Arbitrary number that may only be used once. Can be used to detect replay attacks.
   *
   * @generated from field: bytes nonce = 2;
   */
  nonce: Uint8Array;
};

/**
 * Describes the message common.IdentifierHeader.
 * Use `create(IdentifierHeaderSchema)` to create a new message.
 */
export const IdentifierHeaderSchema: GenMessage<IdentifierHeader> = /*@__PURE__*/
  messageDesc(file_common_common, 3);

/**
 * @generated from message common.Header
 */
export type Header = Message<"common.Header"> & {
  /**
   * @generated from field: bytes channel_header = 1;
   */
  channelHeader: Uint8Array;

  /**
   * @generated from field: bytes signature_header = 2;
   */
  signatureHeader: Uint8Array;
};

/**
 * Describes the message common.Header.
 * Use `create(HeaderSchema)` to create a new message.
 */
export const HeaderSchema: GenMessage<Header> = /*@__PURE__*/
  messageDesc(file_common_common, 4);

/**
 * Header is a generic replay prevention and identity message to include in a signed payload
 *
 * @generated from message common.ChannelHeader
 */
export type ChannelHeader = Message<"common.ChannelHeader"> & {
  /**
   * Header types 0-10000 are reserved and defined by HeaderType
   *
   * @generated from field: int32 type = 1;
   */
  type: number;

  /**
   * Version indicates message protocol version
   *
   * @generated from field: int32 version = 2;
   */
  version: number;

  /**
   * Timestamp is the local time when the message was created
   * by the sender
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  /**
   * Identifier of the channel this message is bound for
   *
   * @generated from field: string channel_id = 4;
   */
  channelId: string;

  /**
   * An unique identifier that is used end-to-end.
   *  -  set by higher layers such as end user or SDK
   *  -  passed to the endorser (which will check for uniqueness)
   *  -  as the header is passed along unchanged, it will be
   *     be retrieved by the committer (uniqueness check here as well)
   *  -  to be stored in the ledger
   *
   * @generated from field: string tx_id = 5;
   */
  txId: string;

  /**
   * The epoch in which this header was generated, where epoch is defined based on block height
   * Epoch in which the response has been generated. This field identifies a
   * logical window of time. A proposal response is accepted by a peer only if
   * two conditions hold:
   * 1. the epoch specified in the message is the current epoch
   * 2. this message has been only seen once during this epoch (i.e. it hasn't
   *    been replayed)
   *
   * @generated from field: uint64 epoch = 6;
   */
  epoch: bigint;

  /**
   * Extension that may be attached based on the header type
   *
   * @generated from field: bytes extension = 7;
   */
  extension: Uint8Array;

  /**
   * If mutual TLS is employed, this represents
   * the hash of the client's TLS certificate
   *
   * @generated from field: bytes tls_cert_hash = 8;
   */
  tlsCertHash: Uint8Array;
};

/**
 * Describes the message common.ChannelHeader.
 * Use `create(ChannelHeaderSchema)` to create a new message.
 */
export const ChannelHeaderSchema: GenMessage<ChannelHeader> = /*@__PURE__*/
  messageDesc(file_common_common, 5);

/**
 * @generated from message common.SignatureHeader
 */
export type SignatureHeader = Message<"common.SignatureHeader"> & {
  /**
   * Creator of the message, a marshaled msp.SerializedIdentity
   *
   * @generated from field: bytes creator = 1;
   */
  creator: Uint8Array;

  /**
   * Arbitrary number that may only be used once. Can be used to detect replay attacks.
   *
   * @generated from field: bytes nonce = 2;
   */
  nonce: Uint8Array;
};

/**
 * Describes the message common.SignatureHeader.
 * Use `create(SignatureHeaderSchema)` to create a new message.
 */
export const SignatureHeaderSchema: GenMessage<SignatureHeader> = /*@__PURE__*/
  messageDesc(file_common_common, 6);

/**
 * Payload is the message contents (and header to allow for signing)
 *
 * @generated from message common.Payload
 */
export type Payload = Message<"common.Payload"> & {
  /**
   * Header is included to provide identity and prevent replay
   *
   * @generated from field: common.Header header = 1;
   */
  header?: Header;

  /**
   * Data, the encoding of which is defined by the type in the header
   *
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;
};

/**
 * Describes the message common.Payload.
 * Use `create(PayloadSchema)` to create a new message.
 */
export const PayloadSchema: GenMessage<Payload> = /*@__PURE__*/
  messageDesc(file_common_common, 7);

/**
 * Envelope wraps a Payload with a signature so that the message may be authenticated
 *
 * @generated from message common.Envelope
 */
export type Envelope = Message<"common.Envelope"> & {
  /**
   * A marshaled Payload
   *
   * @generated from field: bytes payload = 1;
   */
  payload: Uint8Array;

  /**
   * A signature by the creator specified in the Payload header
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message common.Envelope.
 * Use `create(EnvelopeSchema)` to create a new message.
 */
export const EnvelopeSchema: GenMessage<Envelope> = /*@__PURE__*/
  messageDesc(file_common_common, 8);

/**
 * This is finalized block structure to be shared among the orderer and peer
 * Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
 * in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
 * the Metadata is not.
 *
 * @generated from message common.Block
 */
export type Block = Message<"common.Block"> & {
  /**
   * @generated from field: common.BlockHeader header = 1;
   */
  header?: BlockHeader;

  /**
   * @generated from field: common.BlockData data = 2;
   */
  data?: BlockData;

  /**
   * @generated from field: common.BlockMetadata metadata = 3;
   */
  metadata?: BlockMetadata;
};

/**
 * Describes the message common.Block.
 * Use `create(BlockSchema)` to create a new message.
 */
export const BlockSchema: GenMessage<Block> = /*@__PURE__*/
  messageDesc(file_common_common, 9);

/**
 * BlockHeader is the element of the block which forms the block chain
 * The block header is hashed using the configured chain hashing algorithm
 * over the ASN.1 encoding of the BlockHeader
 *
 * @generated from message common.BlockHeader
 */
export type BlockHeader = Message<"common.BlockHeader"> & {
  /**
   * The position in the blockchain
   *
   * @generated from field: uint64 number = 1;
   */
  number: bigint;

  /**
   * The hash of the previous block header
   *
   * @generated from field: bytes previous_hash = 2;
   */
  previousHash: Uint8Array;

  /**
   * The hash of the BlockData, by MerkleTree
   *
   * @generated from field: bytes data_hash = 3;
   */
  dataHash: Uint8Array;
};

/**
 * Describes the message common.BlockHeader.
 * Use `create(BlockHeaderSchema)` to create a new message.
 */
export const BlockHeaderSchema: GenMessage<BlockHeader> = /*@__PURE__*/
  messageDesc(file_common_common, 10);

/**
 * @generated from message common.BlockData
 */
export type BlockData = Message<"common.BlockData"> & {
  /**
   * @generated from field: repeated bytes data = 1;
   */
  data: Uint8Array[];
};

/**
 * Describes the message common.BlockData.
 * Use `create(BlockDataSchema)` to create a new message.
 */
export const BlockDataSchema: GenMessage<BlockData> = /*@__PURE__*/
  messageDesc(file_common_common, 11);

/**
 * @generated from message common.BlockMetadata
 */
export type BlockMetadata = Message<"common.BlockMetadata"> & {
  /**
   * @generated from field: repeated bytes metadata = 1;
   */
  metadata: Uint8Array[];
};

/**
 * Describes the message common.BlockMetadata.
 * Use `create(BlockMetadataSchema)` to create a new message.
 */
export const BlockMetadataSchema: GenMessage<BlockMetadata> = /*@__PURE__*/
  messageDesc(file_common_common, 12);

/**
 * OrdererBlockMetadata defines metadata that is set by the ordering service.
 *
 * @generated from message common.OrdererBlockMetadata
 */
export type OrdererBlockMetadata = Message<"common.OrdererBlockMetadata"> & {
  /**
   * @generated from field: common.LastConfig last_config = 1;
   */
  lastConfig?: LastConfig;

  /**
   * @generated from field: bytes consenter_metadata = 2;
   */
  consenterMetadata: Uint8Array;
};

/**
 * Describes the message common.OrdererBlockMetadata.
 * Use `create(OrdererBlockMetadataSchema)` to create a new message.
 */
export const OrdererBlockMetadataSchema: GenMessage<OrdererBlockMetadata> = /*@__PURE__*/
  messageDesc(file_common_common, 13);

/**
 * These status codes are intended to resemble selected HTTP status codes
 *
 * @generated from enum common.Status
 */
export enum Status {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: SUCCESS = 200;
   */
  SUCCESS = 200,

  /**
   * @generated from enum value: BAD_REQUEST = 400;
   */
  BAD_REQUEST = 400,

  /**
   * @generated from enum value: FORBIDDEN = 403;
   */
  FORBIDDEN = 403,

  /**
   * @generated from enum value: NOT_FOUND = 404;
   */
  NOT_FOUND = 404,

  /**
   * @generated from enum value: REQUEST_ENTITY_TOO_LARGE = 413;
   */
  REQUEST_ENTITY_TOO_LARGE = 413,

  /**
   * @generated from enum value: INTERNAL_SERVER_ERROR = 500;
   */
  INTERNAL_SERVER_ERROR = 500,

  /**
   * @generated from enum value: NOT_IMPLEMENTED = 501;
   */
  NOT_IMPLEMENTED = 501,

  /**
   * @generated from enum value: SERVICE_UNAVAILABLE = 503;
   */
  SERVICE_UNAVAILABLE = 503,
}

/**
 * Describes the enum common.Status.
 */
export const StatusSchema: GenEnum<Status> = /*@__PURE__*/
  enumDesc(file_common_common, 0);

/**
 * @generated from enum common.HeaderType
 */
export enum HeaderType {
  /**
   * Used for messages which are signed but opaque
   *
   * @generated from enum value: MESSAGE = 0;
   */
  MESSAGE = 0,

  /**
   * Used for messages which express the channel config
   *
   * @generated from enum value: CONFIG = 1;
   */
  CONFIG = 1,

  /**
   * Used for transactions which update the channel config
   *
   * @generated from enum value: CONFIG_UPDATE = 2;
   */
  CONFIG_UPDATE = 2,

  /**
   * Used by the SDK to submit endorser based transactions
   *
   * @generated from enum value: ENDORSER_TRANSACTION = 3;
   */
  ENDORSER_TRANSACTION = 3,

  /**
   * Was used internally by the orderer for management, no longer used since system channel was removed
   *
   * @generated from enum value: ORDERER_TRANSACTION = 4 [deprecated = true];
   * @deprecated
   */
  ORDERER_TRANSACTION = 4,

  /**
   * Used as the type for Envelope messages submitted to instruct the Deliver API to seek
   *
   * @generated from enum value: DELIVER_SEEK_INFO = 5;
   */
  DELIVER_SEEK_INFO = 5,

  /**
   * Used for packaging chaincode artifacts for install
   *
   * @generated from enum value: CHAINCODE_PACKAGE = 6;
   */
  CHAINCODE_PACKAGE = 6,
}

/**
 * Describes the enum common.HeaderType.
 */
export const HeaderTypeSchema: GenEnum<HeaderType> = /*@__PURE__*/
  enumDesc(file_common_common, 1);

/**
 * This enum enlists indexes of the block metadata array
 *
 * @generated from enum common.BlockMetadataIndex
 */
export enum BlockMetadataIndex {
  /**
   * Block metadata array position for block signatures
   *
   * @generated from enum value: SIGNATURES = 0;
   */
  SIGNATURES = 0,

  /**
   * Block metadata array position to store last configuration block sequence number
   *
   * @generated from enum value: LAST_CONFIG = 1 [deprecated = true];
   * @deprecated
   */
  LAST_CONFIG = 1,

  /**
   * Block metadata array position to store serialized bit array filter of invalid transactions
   *
   * @generated from enum value: TRANSACTIONS_FILTER = 2;
   */
  TRANSACTIONS_FILTER = 2,

  /**
   * Block metadata array position to store operational metadata for orderers
   *
   * @generated from enum value: ORDERER = 3 [deprecated = true];
   * @deprecated
   */
  ORDERER = 3,

  /**
   * Block metadata array position to store the hash of TRANSACTIONS_FILTER, State Updates,
   * and the COMMIT_HASH of the previous block 
   *
   * @generated from enum value: COMMIT_HASH = 4;
   */
  COMMIT_HASH = 4,
}

/**
 * Describes the enum common.BlockMetadataIndex.
 */
export const BlockMetadataIndexSchema: GenEnum<BlockMetadataIndex> = /*@__PURE__*/
  enumDesc(file_common_common, 2);

