// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.5.1 with parameter "target=ts,keep_empty_files=true"
// @generated from file gateway/gateway.proto (package gateway, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { ChaincodeEvent } from "../peer/chaincode_event_pb";
import { file_peer_chaincode_event } from "../peer/chaincode_event_pb";
import type { SignedProposal } from "../peer/proposal_pb";
import { file_peer_proposal } from "../peer/proposal_pb";
import type { Response } from "../peer/proposal_response_pb";
import { file_peer_proposal_response } from "../peer/proposal_response_pb";
import type { TxValidationCode } from "../peer/transaction_pb";
import { file_peer_transaction } from "../peer/transaction_pb";
import type { Envelope } from "../common/common_pb";
import { file_common_common } from "../common/common_pb";
import type { SeekPosition } from "../orderer/ab_pb";
import { file_orderer_ab } from "../orderer/ab_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file gateway/gateway.proto.
 */
export const file_gateway_gateway: GenFile = /*@__PURE__*/
  fileDesc("ChVnYXRld2F5L2dhdGV3YXkucHJvdG8SB2dhdGV3YXkikwEKDkVuZG9yc2VSZXF1ZXN0EhYKDnRyYW5zYWN0aW9uX2lkGAEgASgJEhIKCmNoYW5uZWxfaWQYAiABKAkSNAoUcHJvcG9zZWRfdHJhbnNhY3Rpb24YAyABKAsyFi5wcm90b3MuU2lnbmVkUHJvcG9zYWwSHwoXZW5kb3JzaW5nX29yZ2FuaXphdGlvbnMYBCADKAkiQQoPRW5kb3JzZVJlc3BvbnNlEi4KFHByZXBhcmVkX3RyYW5zYWN0aW9uGAEgASgLMhAuY29tbW9uLkVudmVsb3BlImsKDVN1Ym1pdFJlcXVlc3QSFgoOdHJhbnNhY3Rpb25faWQYASABKAkSEgoKY2hhbm5lbF9pZBgCIAEoCRIuChRwcmVwYXJlZF90cmFuc2FjdGlvbhgDIAEoCzIQLmNvbW1vbi5FbnZlbG9wZSIQCg5TdWJtaXRSZXNwb25zZSI/ChlTaWduZWRDb21taXRTdGF0dXNSZXF1ZXN0Eg8KB3JlcXVlc3QYASABKAwSEQoJc2lnbmF0dXJlGAIgASgMIlMKE0NvbW1pdFN0YXR1c1JlcXVlc3QSFgoOdHJhbnNhY3Rpb25faWQYASABKAkSEgoKY2hhbm5lbF9pZBgCIAEoCRIQCghpZGVudGl0eRgDIAEoDCJWChRDb21taXRTdGF0dXNSZXNwb25zZRIoCgZyZXN1bHQYASABKA4yGC5wcm90b3MuVHhWYWxpZGF0aW9uQ29kZRIUCgxibG9ja19udW1iZXIYAiABKAQikQEKD0V2YWx1YXRlUmVxdWVzdBIWCg50cmFuc2FjdGlvbl9pZBgBIAEoCRISCgpjaGFubmVsX2lkGAIgASgJEjQKFHByb3Bvc2VkX3RyYW5zYWN0aW9uGAMgASgLMhYucHJvdG9zLlNpZ25lZFByb3Bvc2FsEhwKFHRhcmdldF9vcmdhbml6YXRpb25zGAQgAygJIjQKEEV2YWx1YXRlUmVzcG9uc2USIAoGcmVzdWx0GAEgASgLMhAucHJvdG9zLlJlc3BvbnNlIkIKHFNpZ25lZENoYWluY29kZUV2ZW50c1JlcXVlc3QSDwoHcmVxdWVzdBgBIAEoDBIRCglzaWduYXR1cmUYAiABKAwioQEKFkNoYWluY29kZUV2ZW50c1JlcXVlc3QSEgoKY2hhbm5lbF9pZBgBIAEoCRIUCgxjaGFpbmNvZGVfaWQYAiABKAkSEAoIaWRlbnRpdHkYAyABKAwSLQoOc3RhcnRfcG9zaXRpb24YBCABKAsyFS5vcmRlcmVyLlNlZWtQb3NpdGlvbhIcChRhZnRlcl90cmFuc2FjdGlvbl9pZBgFIAEoCSJXChdDaGFpbmNvZGVFdmVudHNSZXNwb25zZRImCgZldmVudHMYASADKAsyFi5wcm90b3MuQ2hhaW5jb2RlRXZlbnQSFAoMYmxvY2tfbnVtYmVyGAIgASgEIj8KC0Vycm9yRGV0YWlsEg8KB2FkZHJlc3MYASABKAkSDgoGbXNwX2lkGAIgASgJEg8KB21lc3NhZ2UYAyABKAkieAoTUHJvcG9zZWRUcmFuc2FjdGlvbhIWCg50cmFuc2FjdGlvbl9pZBgBIAEoCRIoCghwcm9wb3NhbBgCIAEoCzIWLnByb3Rvcy5TaWduZWRQcm9wb3NhbBIfChdlbmRvcnNpbmdfb3JnYW5pemF0aW9ucxgDIAMoCSJRChNQcmVwYXJlZFRyYW5zYWN0aW9uEhYKDnRyYW5zYWN0aW9uX2lkGAEgASgJEiIKCGVudmVsb3BlGAIgASgLMhAuY29tbW9uLkVudmVsb3BlMvQCCgdHYXRld2F5EjwKB0VuZG9yc2USFy5nYXRld2F5LkVuZG9yc2VSZXF1ZXN0GhguZ2F0ZXdheS5FbmRvcnNlUmVzcG9uc2USOQoGU3VibWl0EhYuZ2F0ZXdheS5TdWJtaXRSZXF1ZXN0GhcuZ2F0ZXdheS5TdWJtaXRSZXNwb25zZRJRCgxDb21taXRTdGF0dXMSIi5nYXRld2F5LlNpZ25lZENvbW1pdFN0YXR1c1JlcXVlc3QaHS5nYXRld2F5LkNvbW1pdFN0YXR1c1Jlc3BvbnNlEj8KCEV2YWx1YXRlEhguZ2F0ZXdheS5FdmFsdWF0ZVJlcXVlc3QaGS5nYXRld2F5LkV2YWx1YXRlUmVzcG9uc2USXAoPQ2hhaW5jb2RlRXZlbnRzEiUuZ2F0ZXdheS5TaWduZWRDaGFpbmNvZGVFdmVudHNSZXF1ZXN0GiAuZ2F0ZXdheS5DaGFpbmNvZGVFdmVudHNSZXNwb25zZTABQmgKJW9yZy5oeXBlcmxlZGdlci5mYWJyaWMucHJvdG9zLmdhdGV3YXlCDEdhdGV3YXlQcm90b1ABWi9naXRodWIuY29tL2h5cGVybGVkZ2VyL2ZhYnJpYy1wcm90b3MtZ28vZ2F0ZXdheWIGcHJvdG8z", [file_peer_chaincode_event, file_peer_proposal, file_peer_proposal_response, file_peer_transaction, file_common_common, file_orderer_ab]);

/**
 * EndorseRequest contains the details required to obtain sufficient endorsements for a
 * transaction to be committed to the ledger.
 *
 * @generated from message gateway.EndorseRequest
 */
export type EndorseRequest = Message<"gateway.EndorseRequest"> & {
  /**
   * The unique identifier for the transaction.
   *
   * @generated from field: string transaction_id = 1;
   */
  transactionId: string;

  /**
   * Identifier of the channel this request is bound for.
   *
   * @generated from field: string channel_id = 2;
   */
  channelId: string;

  /**
   * The signed proposal ready for endorsement.
   *
   * @generated from field: protos.SignedProposal proposed_transaction = 3;
   */
  proposedTransaction?: SignedProposal;

  /**
   * If targeting the peers of specific organizations (e.g. for private data scenarios),
   * the list of organizations' MSPIDs should be supplied here.
   *
   * @generated from field: repeated string endorsing_organizations = 4;
   */
  endorsingOrganizations: string[];
};

/**
 * Describes the message gateway.EndorseRequest.
 * Use `create(EndorseRequestSchema)` to create a new message.
 */
export const EndorseRequestSchema: GenMessage<EndorseRequest> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 0);

/**
 * EndorseResponse returns the result of endorsing a transaction.
 *
 * @generated from message gateway.EndorseResponse
 */
export type EndorseResponse = Message<"gateway.EndorseResponse"> & {
  /**
   * The unsigned set of transaction responses from the endorsing peers for signing by the client
   * before submitting to ordering service (via gateway).
   *
   * @generated from field: common.Envelope prepared_transaction = 1;
   */
  preparedTransaction?: Envelope;
};

/**
 * Describes the message gateway.EndorseResponse.
 * Use `create(EndorseResponseSchema)` to create a new message.
 */
export const EndorseResponseSchema: GenMessage<EndorseResponse> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 1);

/**
 * SubmitRequest contains the details required to submit a transaction (update the ledger).
 *
 * @generated from message gateway.SubmitRequest
 */
export type SubmitRequest = Message<"gateway.SubmitRequest"> & {
  /**
   * Identifier of the transaction to submit.
   *
   * @generated from field: string transaction_id = 1;
   */
  transactionId: string;

  /**
   * Identifier of the channel this request is bound for.
   *
   * @generated from field: string channel_id = 2;
   */
  channelId: string;

  /**
   * The signed set of endorsed transaction responses to submit.
   *
   * @generated from field: common.Envelope prepared_transaction = 3;
   */
  preparedTransaction?: Envelope;
};

/**
 * Describes the message gateway.SubmitRequest.
 * Use `create(SubmitRequestSchema)` to create a new message.
 */
export const SubmitRequestSchema: GenMessage<SubmitRequest> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 2);

/**
 * SubmitResponse returns the result of submitting a transaction.
 *
 * Nothing yet
 *
 * @generated from message gateway.SubmitResponse
 */
export type SubmitResponse = Message<"gateway.SubmitResponse"> & {
};

/**
 * Describes the message gateway.SubmitResponse.
 * Use `create(SubmitResponseSchema)` to create a new message.
 */
export const SubmitResponseSchema: GenMessage<SubmitResponse> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 3);

/**
 * SignedCommitStatusRequest contains a serialized CommitStatusRequest message, and a digital signature for the
 * serialized request message.
 *
 * @generated from message gateway.SignedCommitStatusRequest
 */
export type SignedCommitStatusRequest = Message<"gateway.SignedCommitStatusRequest"> & {
  /**
   * Serialized CommitStatusRequest message.
   *
   * @generated from field: bytes request = 1;
   */
  request: Uint8Array;

  /**
   * Signature for request message.
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message gateway.SignedCommitStatusRequest.
 * Use `create(SignedCommitStatusRequestSchema)` to create a new message.
 */
export const SignedCommitStatusRequestSchema: GenMessage<SignedCommitStatusRequest> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 4);

/**
 * CommitStatusRequest contains the details required to check whether a transaction has been
 * successfully committed.
 *
 * @generated from message gateway.CommitStatusRequest
 */
export type CommitStatusRequest = Message<"gateway.CommitStatusRequest"> & {
  /**
   * Identifier of the transaction to check.
   *
   * @generated from field: string transaction_id = 1;
   */
  transactionId: string;

  /**
   * Identifier of the channel this request is bound for.
   *
   * @generated from field: string channel_id = 2;
   */
  channelId: string;

  /**
   * Client requestor identity.
   *
   * @generated from field: bytes identity = 3;
   */
  identity: Uint8Array;
};

/**
 * Describes the message gateway.CommitStatusRequest.
 * Use `create(CommitStatusRequestSchema)` to create a new message.
 */
export const CommitStatusRequestSchema: GenMessage<CommitStatusRequest> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 5);

/**
 * CommitStatusResponse returns the result of committing a transaction.
 *
 * @generated from message gateway.CommitStatusResponse
 */
export type CommitStatusResponse = Message<"gateway.CommitStatusResponse"> & {
  /**
   * The result of the transaction commit, as defined in peer/transaction.proto.
   *
   * @generated from field: protos.TxValidationCode result = 1;
   */
  result: TxValidationCode;

  /**
   * Block number that contains the transaction.
   *
   * @generated from field: uint64 block_number = 2;
   */
  blockNumber: bigint;
};

/**
 * Describes the message gateway.CommitStatusResponse.
 * Use `create(CommitStatusResponseSchema)` to create a new message.
 */
export const CommitStatusResponseSchema: GenMessage<CommitStatusResponse> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 6);

/**
 * EvaluateRequest contains the details required to evaluate a transaction (query the ledger).
 *
 * @generated from message gateway.EvaluateRequest
 */
export type EvaluateRequest = Message<"gateway.EvaluateRequest"> & {
  /**
   * Identifier of the transaction to evaluate.
   *
   * @generated from field: string transaction_id = 1;
   */
  transactionId: string;

  /**
   * Identifier of the channel this request is bound for.
   *
   * @generated from field: string channel_id = 2;
   */
  channelId: string;

  /**
   * The signed proposal ready for evaluation.
   *
   * @generated from field: protos.SignedProposal proposed_transaction = 3;
   */
  proposedTransaction?: SignedProposal;

  /**
   * If targeting the peers of specific organizations (e.g. for private data scenarios),
   * the list of organizations' MSPIDs should be supplied here.
   *
   * @generated from field: repeated string target_organizations = 4;
   */
  targetOrganizations: string[];
};

/**
 * Describes the message gateway.EvaluateRequest.
 * Use `create(EvaluateRequestSchema)` to create a new message.
 */
export const EvaluateRequestSchema: GenMessage<EvaluateRequest> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 7);

/**
 * EvaluateResponse returns the result of evaluating a transaction.
 *
 * @generated from message gateway.EvaluateResponse
 */
export type EvaluateResponse = Message<"gateway.EvaluateResponse"> & {
  /**
   * The response that is returned by the transaction function, as defined
   * in peer/proposal_response.proto.
   *
   * @generated from field: protos.Response result = 1;
   */
  result?: Response;
};

/**
 * Describes the message gateway.EvaluateResponse.
 * Use `create(EvaluateResponseSchema)` to create a new message.
 */
export const EvaluateResponseSchema: GenMessage<EvaluateResponse> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 8);

/**
 * SignedChaincodeEventsRequest contains a serialized ChaincodeEventsRequest message, and a digital signature for the
 * serialized request message.
 *
 * @generated from message gateway.SignedChaincodeEventsRequest
 */
export type SignedChaincodeEventsRequest = Message<"gateway.SignedChaincodeEventsRequest"> & {
  /**
   * Serialized ChaincodeEventsRequest message.
   *
   * @generated from field: bytes request = 1;
   */
  request: Uint8Array;

  /**
   * Signature for request message.
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message gateway.SignedChaincodeEventsRequest.
 * Use `create(SignedChaincodeEventsRequestSchema)` to create a new message.
 */
export const SignedChaincodeEventsRequestSchema: GenMessage<SignedChaincodeEventsRequest> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 9);

/**
 * ChaincodeEventsRequest contains details of the chaincode events that the caller wants to receive.
 *
 * @generated from message gateway.ChaincodeEventsRequest
 */
export type ChaincodeEventsRequest = Message<"gateway.ChaincodeEventsRequest"> & {
  /**
   * Identifier of the channel this request is bound for.
   *
   * @generated from field: string channel_id = 1;
   */
  channelId: string;

  /**
   * Name of the chaincode for which events are requested.
   *
   * @generated from field: string chaincode_id = 2;
   */
  chaincodeId: string;

  /**
   * Client requestor identity.
   *
   * @generated from field: bytes identity = 3;
   */
  identity: Uint8Array;

  /**
   * Position within the ledger at which to start reading events.
   *
   * @generated from field: orderer.SeekPosition start_position = 4;
   */
  startPosition?: SeekPosition;

  /**
   * Only returns events after this transaction ID. Transactions up to and including this one should be ignored. This
   * is used to allow resume of event listening from a certain position within a start block specified by
   * start_position.
   *
   * @generated from field: string after_transaction_id = 5;
   */
  afterTransactionId: string;
};

/**
 * Describes the message gateway.ChaincodeEventsRequest.
 * Use `create(ChaincodeEventsRequestSchema)` to create a new message.
 */
export const ChaincodeEventsRequestSchema: GenMessage<ChaincodeEventsRequest> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 10);

/**
 * ChaincodeEventsResponse returns chaincode events emitted from a specific block.
 *
 * @generated from message gateway.ChaincodeEventsResponse
 */
export type ChaincodeEventsResponse = Message<"gateway.ChaincodeEventsResponse"> & {
  /**
   * Chaincode events emitted by the requested chaincode. The events are presented in the same order that the
   * transactions that emitted them appear within the block.
   *
   * @generated from field: repeated protos.ChaincodeEvent events = 1;
   */
  events: ChaincodeEvent[];

  /**
   * Block number in which the chaincode events were emitted.
   *
   * @generated from field: uint64 block_number = 2;
   */
  blockNumber: bigint;
};

/**
 * Describes the message gateway.ChaincodeEventsResponse.
 * Use `create(ChaincodeEventsResponseSchema)` to create a new message.
 */
export const ChaincodeEventsResponseSchema: GenMessage<ChaincodeEventsResponse> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 11);

/**
 * If any of the functions in the Gateway service returns an error, then it will be in the format of
 * a google.rpc.Status message. The 'details' field of this message will be populated with extra
 * information if the error is a result of one or more failed requests to remote peers or orderer nodes.
 * ErrorDetail contains details of errors that are received by any of the endorsing peers
 * as a result of processing the Evaluate or Endorse services, or from the ordering node(s) as a result of
 * processing the Submit service.
 *
 * @generated from message gateway.ErrorDetail
 */
export type ErrorDetail = Message<"gateway.ErrorDetail"> & {
  /**
   * The address of the endorsing peer or ordering node that returned an error.
   *
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * The MSP Identifier of this node.
   *
   * @generated from field: string msp_id = 2;
   */
  mspId: string;

  /**
   * The error message returned by this node.
   *
   * @generated from field: string message = 3;
   */
  message: string;
};

/**
 * Describes the message gateway.ErrorDetail.
 * Use `create(ErrorDetailSchema)` to create a new message.
 */
export const ErrorDetailSchema: GenMessage<ErrorDetail> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 12);

/**
 * ProposedTransaction contains the details required for offline signing prior to evaluating or endorsing
 * a transaction.
 *
 * @generated from message gateway.ProposedTransaction
 */
export type ProposedTransaction = Message<"gateway.ProposedTransaction"> & {
  /**
   * Identifier of the proposed transaction.
   *
   * @generated from field: string transaction_id = 1;
   */
  transactionId: string;

  /**
   * The signed proposal.
   *
   * @generated from field: protos.SignedProposal proposal = 2;
   */
  proposal?: SignedProposal;

  /**
   * The list of endorsing organizations.
   *
   * @generated from field: repeated string endorsing_organizations = 3;
   */
  endorsingOrganizations: string[];
};

/**
 * Describes the message gateway.ProposedTransaction.
 * Use `create(ProposedTransactionSchema)` to create a new message.
 */
export const ProposedTransactionSchema: GenMessage<ProposedTransaction> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 13);

/**
 * PreparedTransaction contains the details required for offline signing prior to submitting a transaction.
 *
 * @generated from message gateway.PreparedTransaction
 */
export type PreparedTransaction = Message<"gateway.PreparedTransaction"> & {
  /**
   * Identifier of the prepared transaction.
   *
   * @generated from field: string transaction_id = 1;
   */
  transactionId: string;

  /**
   * The transaction envelope.
   *
   * @generated from field: common.Envelope envelope = 2;
   */
  envelope?: Envelope;
};

/**
 * Describes the message gateway.PreparedTransaction.
 * Use `create(PreparedTransactionSchema)` to create a new message.
 */
export const PreparedTransactionSchema: GenMessage<PreparedTransaction> = /*@__PURE__*/
  messageDesc(file_gateway_gateway, 14);

/**
 * The Gateway API for evaluating and submitting transactions via the gateway.
 * Transaction evaluation (query) requires the invocation of the Evaluate service
 * Transaction submission (ledger updates) is a two step process invoking Endorse
 * followed by Submit. A third step, invoking CommitStatus, is required if the
 * clients wish to wait for a Transaction to be committed.
 * The proposal and transaction must be signed by the client before each step.
 *
 * @generated from service gateway.Gateway
 */
export const Gateway: GenService<{
  /**
   * The Endorse service passes a proposed transaction to the gateway in order to
   * obtain sufficient endorsement.
   * The gateway will determine the endorsement plan for the requested chaincode and
   * forward to the appropriate peers for endorsement. It will return to the client a
   * prepared transaction in the form of an Envelope message as defined
   * in common/common.proto. The client must sign the contents of this envelope
   * before invoking the Submit service.
   *
   * @generated from rpc gateway.Gateway.Endorse
   */
  endorse: {
    methodKind: "unary";
    input: typeof EndorseRequestSchema;
    output: typeof EndorseResponseSchema;
  },
  /**
   * The Submit service will process the prepared transaction returned from Endorse service
   * once it has been signed by the client. It will wait for the transaction to be submitted to the
   * ordering service but the client must invoke the CommitStatus service to wait for the transaction
   * to be committed.
   *
   * @generated from rpc gateway.Gateway.Submit
   */
  submit: {
    methodKind: "unary";
    input: typeof SubmitRequestSchema;
    output: typeof SubmitResponseSchema;
  },
  /**
   * The CommitStatus service will indicate whether a prepared transaction previously submitted to
   * the Submit service has been committed. It will wait for the commit to occur if it hasn’t already
   * committed.
   *
   * @generated from rpc gateway.Gateway.CommitStatus
   */
  commitStatus: {
    methodKind: "unary";
    input: typeof SignedCommitStatusRequestSchema;
    output: typeof CommitStatusResponseSchema;
  },
  /**
   * The Evaluate service passes a proposed transaction to the gateway in order to invoke the
   * transaction function and return the result to the client. No ledger updates are made.
   * The gateway will select an appropriate peer to query based on block height and load.
   *
   * @generated from rpc gateway.Gateway.Evaluate
   */
  evaluate: {
    methodKind: "unary";
    input: typeof EvaluateRequestSchema;
    output: typeof EvaluateResponseSchema;
  },
  /**
   * The ChaincodeEvents service supplies a stream of responses, each containing all the events emitted by the
   * requested chaincode for a specific block. The streamed responses are ordered by ascending block number. Responses
   * are only returned for blocks that contain the requested events, while blocks not containing any of the requested
   * events are skipped.
   *
   * @generated from rpc gateway.Gateway.ChaincodeEvents
   */
  chaincodeEvents: {
    methodKind: "server_streaming";
    input: typeof SignedChaincodeEventsRequestSchema;
    output: typeof ChaincodeEventsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_gateway_gateway, 0);

